\documentclass[10pt,a4paper,draft]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{titling}
\usepackage{mathtools}
\usepackage[finnish]{babel}
\usepackage[left=3cm,top=3cm,right=3cm,bottom=3cm,bindingoffset=0cm]{geometry}
\newcommand{\subtitle}[1]{%
  \posttitle{
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5cm}
}
\begin{document}
\author{
	Mikko Malkavaara\\
	\texttt{mmmalk@utu.fi}\\
	517788
	\and
	Vili Ahava\\
	\texttt{vsahav@utu.fi}\\
	516680\\
	\\
	\hspace{-4.5cm}
	Maks Turtiainen\\
	\hspace{-4.5cm}
	\texttt{mjturt@utu.fi}\\
	\hspace{-4.5cm}
	517579
}
\date{\vfill
Työn ohjaaja:\\
Hanna Ahtosalo\\
\texttt{hakrah@utu.fi}}
\title{Olio-ohjelmoinnin peruskurssi}
\subtitle{Harjoitustyö\vspace{5cm}}
\begin{titlingpage}
	\maketitle
\end{titlingpage}
\tableofcontents
\newpage
\section{Tehtävän kuvaus ja analysointi}
\subsection{Tehtävänanto}
\paragraph{Tehtävänantona oli toteuttaa yksinkertainen peli, jossa on komentorivipohjainen tai graafinen käyttöliittymä. Lisäksi pelin tulisi mahdollistaa tilan tallentaminen, ja muita mahdollisia ominaisuuksia mainittiin esimerkiksi ns. ''high score'' -taulu. Lisäksi toinen mahdollinen aihe oli itse keksitty aihe. Vaikka tämä ratkaisu ei välttämättä sovikaan puhtaasti kumpaankaan aiheeseen, päädyimme rajaamaan projektin toteutetulla tavalla rajoitetun ajan takia. Työ myös pyrittiin toteuttamaan kovakoodaamalla mahdollisimman vähän mitään, vaan kaikki pyritään luomaan lennossa tai lukemaan ulkoisista resursseista.}

\section{Ratkaisuperiaate}
\paragraph{Tehtävänannon perusteella päätimme tehdä yksinkertaisen roolipelin. Pelin tarkoituksena on päästä satunnaisesti valitusta aloitusruudusta niinikään satunnaisesti valittuun maaliruutuun. Koska pelillisesti pelkkä sokkelossa navigoiminen ei olisi kovin mielenkiintoinen, tai laajuudeltaan järin sopiva harjoitustyön aiheeksi mielestämme, päädyimme toteuttamaan peliin myös satunnaisia kohtaamisia vihollisten kanssa.}
\paragraph{Itse peli koostuu kahdesta näkymästä, karttaruudusta jolla liikutaan sekä taisteluruudulla, jossa kohtaamiset vihollisten kanssa tapahtuvat. Nämä näkymät toteutettiin graafisesti, käyttäen hyväksi javan awt- ja swing-kirjastoja. Näissä näkymissä pelaajan syöte luetaan näppäimistöltä, ja palaute tulostetaan ruudulle(joko esimerkiksi graafisena liikkeen ilmentymänä tai tekstimuotoisena syötteenä jonkin asian tapahtumisesta). Satunnaiskohtaamiset vihollisten kanssa tarkistetaan karttaruudulla satunnaislukuja generoimalla, ja kohtaamisen tullessa vastaan käynnistetään pelin kohtaamisnäkymä.}

\subsection{Pelaajan ja vihollisten luokat}
\paragraph{Taistelujärjestelmän näkökulmasta pelaaja ja vihollinen ovat vain yliluokan \texttt{Creature} ilmentymiä, joilla on jaettuja attribuutteja(esimerkiksi nimi, osumapisteet, eri statistiikat jne). \texttt{Creature}-luokka sisältää myös tiedot ilmentymiensä tietämistä hyök\-käy\-ksi\-stä, inventaariosta ja loitsuista. Havainnointi- ja asetusmetodiensa lisäksi \texttt{Creature}-luokalla on myös metodit myös taistelussa hyökkäyksien aikaansaamoan vahingon laskemiseen ja tekemiseen, esineiden käyttämiselle sekä myös kehityspisteiden tarkistamiseksi voidaanko seuraava kehitystaso saavuttaa(sekä myös itse kehitystason ja ilmentymien statistiikkojen nosto) }
\paragraph{Pelihahmon luokalla on myös yliluokkansa sisältämien tietojen lisäksi tieto missä kohtaa pelihahmo sijaitsee karttaruudulla, sekä tälle asetus- ja havainnointimetodit. Näiden lisäksi pelihahmolle on myös metodit, joilla liikutaan pelimaailmassa eri suuntiin(kuitenkin graafisella käyttöliittymällä on tähän omat metodinsa). Näitä metodeja on käytetty koodin testaamiseen ja prototyyppaukseen ennen kuin varsinaisen graafisen käyttöliittymän kehitystä oli aloitettu.}
\paragraph{Vihollisen luokalla on vain yksi oma metodi, jonka avulla käydään lävitse lista vihollisen tietämistä loitsuista sekä hyökkäyksistä, ja lasketaan isoin mahdollinen vahinko minkä vihollinen pystyy hyökkäyksen kohteeseen tekemään. Loitsuja läpikäyvä silmukka jättää vertailusta pois sellaiset loitsut, joiden käyttämiseen vihollisen taikapisteet eivät riitä.}
\newpage
\paragraph{Pelissä jokainen kukistettu vihollinen kerryttää omien elämäpisteidensä verran kokemuspisteitä. Pelaajan tarvitsemat kokemuspisteet lasketaan seuraavalla kaavalla:}
\[\frac{5\cdot player.level}{4}\]
\paragraph{Tämän lisäksi \texttt{Creaturen} kehitystason noustessa attribuutit voima, puolustus, taika, sekä taika- ja kestävyyspisteet nousevat noudattaen seuraavaa kaavaa, tämän lisäksi \texttt{Creaturen} voima- ja kestävyyspisteet asetetaan uusiin maksimeihinsa}
\[\lfloor\frac{creature.level+10}{10}\rfloor\]
\paragraph{\texttt{Creature}-luokan ilmentymän tekemä vahinko lasketaan puolestaan käyttäen hyväksi seuraavaa kaavaa:}
\[\frac{\frac{attacker.strength}{defender.defense} \cdot attack.strength \cdot (\frac{attacker.level \cdot 2}{5}+2)}{50}+2\]
\paragraph{Loitsut noudattavat samaa kaavaa, paitsi että voima ja puolustus korvataan hyök\-kää\-jän ja puolustuksen taikavoimalla.}


\subsection{Vihollis-, hyökkäys-, esine- ja loitsulistaukset}
\paragraph{Koska pelisuunnittelu on muutenkin tarpeeksi epäkiitollista toimintaa, päätimme helpottaa omaa elämäämme toteuttamalla metodin, joka lukee peliin luotavia olioita tiedostosta. Halusimme, että tämä data on helposti muokattavissa nopean kehityksen mahdollistamiseksi ilman erikoistyökaluja, joten nämä tiedot tallennetaan utf-8-muotoiltuna pilkulla erotettuna tietueena tekstitiedostossa. Nämä tiedot luetaan riveittäin tiedostosta, ja niitä käytetään uuden olion alustamisessa, ja vihollistiedostossa on tämän lisäksi myös tiedot vihollisen tietämistä loitsuista ja hyökkäyksistä.}
\paragraph{Lisäksi kirjoitimme luokat vihollisten ja esineiden generointiin. Vihollisten generoinnin tapauksessa luetaan tiedostosta vihollisten tiedot uusiksi olioiksi, ja näihin olioihin lisätään niiden tietämät loitsut sekä hyökkäykset. Näitä vihollisia palauttava koodi myös määrittää millä tasolla vihollisen kehitystaso on, ja nostaa sitä ennen vihollisolion palauttamista.}

\subsection{Taistelumoottori}
\paragraph{Itse taistelumoottori järjestää taistelun pelaajan ja vihollisolion välillä. Varsinainen silmukka käsittelee käyttäjän syötteen näppäimistöltä, ja tulostaa ruudulle pelaajan ja vihollisen kannalta oleelliset tiedot. Pelaaja ja vihollinen toimivat vuorotellen tuossa järjestyksessä, ja pelisilmukka tulostaa aina uudet tiedot joka vuoron jälkeen. Pelisilmukkaa ajetaan kunnes jommaltakummalta, pelaajalta tai viholliselta kestävyys\-pisteet putoavat nollaan tai sen alle, ja jos pelaaja selvisi elossa annetaan pelaajalle vihollisen kestävyyspisteiden verran kokemuspisteistä. Tämän lisäksi on pelaajalla mahdollisuus saada satunnaisesti generoituja esineitä, joiden määrä perustuu vihollisen kehitystasoon. }

\subsection{Maailman luominen}
\paragraph{Peliä varten luodaan jokaiselle uudelle pelikerralle uusi maailma. Tämä pelimaailma koostuu ns \emph{tileistä}, joka on pienempi ruutu pelimaailmaa. Yksi tile sisältää aina tiedon minkätyyppinen se on, ts. voiko pelaaja kävellä sen läpi vai ei. Graafista käyttöliittymää varten määrittelimme yhden tilen kooksi 64 x 64 pikseliä.}
\paragraph{Maailma luodaan tileistä koostuvana taulukkona, jolle voidaan antaa haluttu koko pysty- ja vaakasuunnassa. Algoritmi luo ensin Tile-taulukon, johon se lähtee muodostamaan eri reittejä satunnaislukugeneraation avulla muodostaen yhtenäisiä "ratoja". Itse metodi siis asettaa tilen tilan sellaiseksi, että pelaaja pystyy kulkemaan siitä lävitse. Tämän jälkeen toisella metodilla puhkotaan satunnaisiin väleihin sokkelossa reikiä asettamalla ruutuja sellaisiksi että pelaaja pääsee kävelemään niistä}

\subsection{Graafinen käyttöliittymä}
\paragraph{Graafinen käyttöliittymä koostuu lähinnä kahdesta ikkunasta, maailmanäkymästä se\-kä taistelunäkymästä. Kumpikin suunniteltiin niin, että käyttöliittymä hoitaa vain pelin piirtämisen ja käyttäjän syötteen lukemisen.}
\paragraph{Pelin karttanäkymä koostuu kolmesta pääelementistä, itse tasosta jolle kaikki piirretään, kartalle piirrettävistä maastoista sekä pelihahmosta. Koska pelimaailma ja ikkuna kumpikin voivat olla mielivaltaisen kokoisia, toteutettiin pelinäkymän piir\-tä\-mi\-nen niin, että pelihahmo pysyy keskellä ruutua ja maailma liikkuu pelihahmon alla. Pelille luodaan siis uusi ikkuna, johon luodaan uusi maailma ja pelaaja. Tämän jälkeen näille tehdään graafiset ilmentymät jotka piirretään ruudulle ja käyttäjän syöte luetaan tietyin väliajoin. Lisäksi maailman pelinäkymä käyttää erillistä \texttt{handler}-luokkaa hoitamaan objektien päivityksen.}
\paragraph{Taistelunäkymä pelissä toimii piirtämällä uuden ikkunan, johon luodaan pelaajan mahdolliset toiminnot \texttt{Swing}-kirjastoa hyväksikäyttäen valmiita painike-luokkia. Nä\-mä tiedot luetaan pelaaja-luokan tiedoista ja generoidaan dynaamisesti, ja ne sidotaan taistelumoottorin metodeihin. Taistelunäkymä saa fokuksen maailmanäkymältä ja se luodaan maailmanäkymän ali-ikkunana. Koska esimerkiksi pelaajan esinelistaus saattaa vaihdella, luodaan käyttöliittymäelementit siihen lennosta}

\subsection{Pelitilanteen tallennus ja lataus}
\paragraph{Pelitilanne on mahdollista tallentaa ja ladata käyttämällä hyväksi pelimoottorin \texttt{han\-dler}-luokkaa. Tämä luokka tallennetaan /sav-kansion alle binääriobjektina tiedostoon, ja se voidaan lukea sieltä vapaasti käyttäen hyväksi siihen kirjoitettua metodia.}


\section{Ohjelman ja sen osien kuvaaminen}
\paragraph{tähän tulee ne perhanan luokkakaaviot}

\section{Testausjärjestely}
\paragraph{Harjoitustyötä tehdessä käytimme hyväksemme kahdenlaista testausstrategiaa; pelitestausta sekä myöskin metodien toimintaa testaavia prototyyppejä tulevista funktioista. Nämä testikoodit eivät kuitenkaan olleet varsinaisia yksikkötestejä, vaan lä\-hin\-nä komentorivipohjaisia toteutuksia asioista jotka lisättiin graafiseen käyttöliittymään myöhemmin. Varsinaisessa pelitestauksessa samoja toimintoja toistettiin useampaan otteeseen ja usein näin löydettiinkin ennakkoimattomia virheitä ja poikkeustilanteita, jotka saatiin korjattua melko ripeästi. Pelissä ei nykytietämyksen mukaan ole mahdollisia virhetilanteita.}

\newpage
\section{Liitteet}
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}
\subsection{foo}
\subsection{bar}
\end{document}